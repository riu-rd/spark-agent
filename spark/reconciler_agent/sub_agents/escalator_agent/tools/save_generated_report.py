"""Tool for saving LLM-generated reports to the database."""

import os
import asyncio
import asyncpg
from datetime import datetime
from typing import Dict, Any, Optional
from google.adk.tools.tool_context import ToolContext
from dotenv import load_dotenv

load_dotenv()


def save_generated_report(
    transaction_id: str,
    report_content: str,
    report_type: str = "ESCALATION",
    priority: str = "MEDIUM",
    tool_context: Optional[ToolContext] = None
) -> Dict[str, Any]:
    """
    Save an LLM-generated report to the messages table.
    
    Args:
        transaction_id: The transaction ID this report is for
        report_content: The full markdown-formatted report content generated by the LLM
        report_type: Type of report (SUCCESS, ESCALATION, RISK_ESCALATION)
        priority: Priority level (LOW, MEDIUM, HIGH, CRITICAL)
        tool_context: The tool context from ADK
    
    Returns:
        Dictionary containing save status and report metadata
    """
    
    if not transaction_id or not report_content:
        return {
            "status": "error",
            "message": "Transaction ID and report content are required"
        }
    
    # Validate report type
    valid_types = ["SUCCESS", "ESCALATION", "RISK_ESCALATION"]
    if report_type not in valid_types:
        return {
            "status": "error",
            "message": f"Invalid report type. Must be one of: {', '.join(valid_types)}"
        }
    
    # Get database credentials from environment
    db_config = {
        'database': os.getenv('DB_NAME'),
        'host': os.getenv('DB_HOST'),
        'port': int(os.getenv('DB_PORT', 5432)),
        'user': os.getenv('DB_USER'),
        'password': os.getenv('DB_PASSWORD')
    }
    
    # Run the async function synchronously
    async def _async_save_report():
        conn = None
        try:
            # Create connection
            conn = await asyncpg.connect(**db_config)
            
            # Generate report ID
            timestamp_str = datetime.now().strftime("%Y%m%d%H%M%S")
            
            # Determine report prefix based on type
            if report_type == "RISK_ESCALATION":
                report_prefix = "RISK_ESC"
            elif report_type == "SUCCESS":
                report_prefix = "SUC"
            else:
                report_prefix = "ESC"
            
            report_id = f"{report_prefix}_{timestamp_str}_{transaction_id}"
            
            # Get the next message_id (integer)
            max_id_result = await conn.fetchrow("SELECT COALESCE(MAX(message_id), 0) as max_id FROM messages")
            next_message_id = max_id_result['max_id'] + 1
            
            # Add metadata header to the report
            metadata_header = f"""## Report Metadata

- **Report ID**: {report_id}
- **Report Type**: {report_type}
- **Priority**: {priority}
- **Generated**: {datetime.now().isoformat()}
- **Message ID**: {next_message_id}

---

"""
            
            # Combine metadata with the LLM-generated report
            full_report = metadata_header + report_content
            
            # Save the report to the messages table
            insert_query = """
                INSERT INTO messages (message_id, transaction_id, report)
                VALUES ($1, $2, $3)
            """
            
            await conn.execute(
                insert_query,
                next_message_id,
                transaction_id,
                full_report
            )
            
            # Update the transaction to mark it as escalated if needed
            if report_type in ["ESCALATION", "RISK_ESCALATION"]:
                update_query = """
                    UPDATE transactions
                    SET manual_escalation_needed = TRUE
                    WHERE transaction_id = $1
                """
                await conn.execute(update_query, transaction_id)
            
            await conn.close()
            
            return {
                "status": "success",
                "message": f"Report saved successfully",
                "report_id": report_id,
                "message_id": next_message_id,
                "transaction_id": transaction_id,
                "report_type": report_type,
                "priority": priority,
                "created_at": datetime.now().isoformat()
            }
            
        except Exception as e:
            if conn:
                await conn.close()
            return {
                "status": "error",
                "message": f"Failed to save report: {str(e)}"
            }
    
    # Execute the async function
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # Create a new thread to run the async function
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, _async_save_report())
                return future.result()
        else:
            return loop.run_until_complete(_async_save_report())
    except RuntimeError:
        # Fallback for when no event loop exists
        return asyncio.run(_async_save_report())